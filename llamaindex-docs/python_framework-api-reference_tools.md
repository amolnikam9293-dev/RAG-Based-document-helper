# Index
##  DefaultToolFnSchema [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.DefaultToolFnSchema "Permanent link")
Bases: `BaseModel`
Default tool function Schema.
Parameters:
Name | Type | Description | Default  
---|---|---|---  
`input` |  _required_  
Source code in `llama_index/core/tools/types.py`
```
17
18
19
20
```
| ```
class DefaultToolFnSchema(BaseModel):
"""Default tool function Schema."""

    input: str

```
  
---|---  
##  ToolMetadata `dataclass` [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.ToolMetadata "Permanent link")
ToolMetadata(description: str, name: Optional[str] = None, fn_schema: Optional[Type[pydantic.main.BaseModel]] = , return_direct: bool = False)
Parameters:
Name | Type | Description | Default  
---|---|---|---  
`description` |  _required_  
`name` |  `str | None` |  `None`  
`fn_schema` |  `Type[BaseModel] | None` |  `<class 'llama_index.core.tools.types.DefaultToolFnSchema'>`  
`return_direct` |  `bool` |  `False`  
Source code in `llama_index/core/tools/types.py`
```
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
```
| ```
@dataclass
class ToolMetadata:
    description: str
    name: Optional[str] = None
    fn_schema: Optional[Type[BaseModel]] = DefaultToolFnSchema
    return_direct: bool = False

    def get_parameters_dict(self) -> dict:
        if self.fn_schema is None:
            parameters = {
                "type": "object",
                "properties": {
                    "input": {"title": "input query string", "type": "string"},
                },
                "required": ["input"],
            }
        else:
            parameters = self.fn_schema.model_json_schema()
            parameters = {
                k: v
                for k, v in parameters.items()
                if k in ["type", "properties", "required", "definitions", "$defs"]
            }
        return parameters

    @property
    def fn_schema_str(self) -> str:
"""Get fn schema as string."""
        if self.fn_schema is None:
            raise ValueError("fn_schema is None.")
        parameters = self.get_parameters_dict()
        return json.dumps(parameters, ensure_ascii=False)

    def get_name(self) -> str:
"""Get name."""
        if self.name is None:
            raise ValueError("name is None.")
        return self.name

    def _sanitize_name(self, name: Optional[str]) -> Optional[str]:
"""
        Sanitize name to match OpenAI's function name requirements.

        OpenAI requires function names to match ^[a-zA-Z0-9_-]+$.
        Generic Pydantic models like GenericModel[int] contain brackets
        which are not allowed.
        """
        if name is None:
            return None
        return re.sub(r"[^a-zA-Z0-9_-]", "_", name)

    @deprecated(
        "Deprecated in favor of `to_openai_tool`, which should be used instead."
    )
    def to_openai_function(self) -> Dict[str, Any]:
"""
        Deprecated and replaced by `to_openai_tool`.
        The name and arguments of a function that should be called, as generated by the
        model.
        """
        return {
            "name": self._sanitize_name(self.name),
            "description": self.description,
            "parameters": self.get_parameters_dict(),
        }

    def to_openai_tool(self, skip_length_check: bool = False) -> Dict[str, Any]:
"""To OpenAI tool."""
        if not skip_length_check and len(self.description)  1024:
            raise ValueError(
                "Tool description exceeds maximum length of 1024 characters. "
                "Please shorten your description or move it to the prompt."
            )
        return {
            "type": "function",
            "function": {
                "name": self._sanitize_name(self.name),
                "description": self.description,
                "parameters": self.get_parameters_dict(),
            },
        }

```
  
---|---  
###  fn_schema_str `property` [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.ToolMetadata.fn_schema_str "Permanent link")
```
fn_schema_str: 

```

Get fn schema as string.
###  get_name [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.ToolMetadata.get_name "Permanent link")
```
get_name() -> 

```

Get name.
Source code in `llama_index/core/tools/types.py`
```
56
57
58
59
60
```
| ```
def get_name(self) -> str:
"""Get name."""
    if self.name is None:
        raise ValueError("name is None.")
    return self.name

```
  
---|---  
###  to_openai_function [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.ToolMetadata.to_openai_function "Permanent link")
```
to_openai_function() -> [, ]

```

Deprecated and replaced by `to_openai_tool`. The name and arguments of a function that should be called, as generated by the model.
Source code in `llama_index/core/tools/types.py`
```
74
75
76
77
78
79
80
81
82
83
84
85
86
87
```
| ```
@deprecated(
    "Deprecated in favor of `to_openai_tool`, which should be used instead."
)
def to_openai_function(self) -> Dict[str, Any]:
"""
    Deprecated and replaced by `to_openai_tool`.
    The name and arguments of a function that should be called, as generated by the
    model.
    """
    return {
        "name": self._sanitize_name(self.name),
        "description": self.description,
        "parameters": self.get_parameters_dict(),
    }

```
  
---|---  
###  to_openai_tool [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.ToolMetadata.to_openai_tool "Permanent link")
```
to_openai_tool(skip_length_check:  = False) -> [, ]

```

To OpenAI tool.
Source code in `llama_index/core/tools/types.py`
```
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
```
| ```
def to_openai_tool(self, skip_length_check: bool = False) -> Dict[str, Any]:
"""To OpenAI tool."""
    if not skip_length_check and len(self.description)  1024:
        raise ValueError(
            "Tool description exceeds maximum length of 1024 characters. "
            "Please shorten your description or move it to the prompt."
        )
    return {
        "type": "function",
        "function": {
            "name": self._sanitize_name(self.name),
            "description": self.description,
            "parameters": self.get_parameters_dict(),
        },
    }

```
  
---|---  
##  ToolOutput [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.ToolOutput "Permanent link")
Bases: `BaseModel`
Tool output.
Parameters:
Name | Type | Description | Default  
---|---|---|---  
`blocks` |  `List[Annotated[Union[TextBlock[](https://developers.llamaindex.ai/python/framework-api-reference/llms/#llama_index.core.base.llms.types.TextBlock "llama_index.core.base.llms.types.TextBlock"), ImageBlock, AudioBlock, DocumentBlock, CachePoint, CitableBlock, CitationBlock], FieldInfo]]` |  _required_  
`tool_name` |  _required_  
`raw_input` |  `Dict[str, Any]` |  _required_  
`raw_output` |  _required_  
`is_error` |  `bool` |  `False`  
Source code in `llama_index/core/tools/types.py`
```
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
```
| ```
class ToolOutput(BaseModel):
"""Tool output."""

    blocks: List[ContentBlock]
    tool_name: str
    raw_input: Dict[str, Any]
    raw_output: Any
    is_error: bool = False

    _exception: Optional[Exception] = PrivateAttr(default=None)

    def __init__(
        self,
        tool_name: str,
        content: Optional[str] = None,
        blocks: Optional[List[ContentBlock]] = None,
        raw_input: Optional[Dict[str, Any]] = None,
        raw_output: Optional[Any] = None,
        is_error: bool = False,
        exception: Optional[Exception] = None,
    ):
        if content and blocks:
            raise ValueError("Cannot provide both content and blocks.")
        if content:
            blocks = [TextBlock(text=content)]
        elif blocks:
            pass
        else:
            blocks = []

        super().__init__(
            tool_name=tool_name,
            blocks=blocks,
            raw_input=raw_input,
            raw_output=raw_output,
            is_error=is_error,
        )

        self._exception = exception

    @property
    def content(self) -> str:
"""Get the content of the tool output."""
        return "\n".join(
            [block.text for block in self.blocks if isinstance(block, TextBlock)]
        )

    @content.setter
    def content(self, content: str) -> None:
"""Set the content of the tool output."""
        self.blocks = [TextBlock(text=content)]

    @property
    def exception(self) -> Optional[Exception]:
"""Get the exception of the tool output."""
        return self._exception

    def __str__(self) -> str:
"""String."""
        return self.content

```
  
---|---  
###  content `property` `writable` [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.ToolOutput.content "Permanent link")
```
content: 

```

Get the content of the tool output.
###  exception `property` [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.ToolOutput.exception "Permanent link")
```
exception: Optional[Exception]

```

Get the exception of the tool output.
##  BaseTool [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.BaseTool "Permanent link")
Bases: `DispatcherSpanMixin`
Source code in `llama_index/core/tools/types.py`
```
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
```
| ```
class BaseTool(DispatcherSpanMixin):
    @property
    @abstractmethod
    def metadata(self) -> ToolMetadata:
        pass

    @abstractmethod
    def __call__(self, input: Any) -> ToolOutput:
        pass

    def _process_langchain_tool_kwargs(
        self,
        langchain_tool_kwargs: Any,
    ) -> Dict[str, Any]:
"""Process langchain tool kwargs."""
        if "name" not in langchain_tool_kwargs:
            langchain_tool_kwargs["name"] = self.metadata.name or ""
        if "description" not in langchain_tool_kwargs:
            langchain_tool_kwargs["description"] = self.metadata.description
        if "fn_schema" not in langchain_tool_kwargs:
            langchain_tool_kwargs["args_schema"] = self.metadata.fn_schema

        # Callback dont exist on langchain
        if "_callback" in langchain_tool_kwargs:
            del langchain_tool_kwargs["_callback"]
        if "_async_callback" in langchain_tool_kwargs:
            del langchain_tool_kwargs["_async_callback"]

        return langchain_tool_kwargs

    def to_langchain_tool(
        self,
        **langchain_tool_kwargs: Any,
    ) -> "Tool":
"""To langchain tool."""
        from llama_index.core.bridge.langchain import Tool

        langchain_tool_kwargs = self._process_langchain_tool_kwargs(
            langchain_tool_kwargs
        )
        return Tool.from_function(
            func=self.__call__,
            **langchain_tool_kwargs,
        )

    def to_langchain_structured_tool(
        self,
        **langchain_tool_kwargs: Any,
    ) -> "StructuredTool":
"""To langchain structured tool."""
        from llama_index.core.bridge.langchain import StructuredTool

        langchain_tool_kwargs = self._process_langchain_tool_kwargs(
            langchain_tool_kwargs
        )
        return StructuredTool.from_function(
            func=self.__call__,
            **langchain_tool_kwargs,
        )

```
  
---|---  
###  to_langchain_tool [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.BaseTool.to_langchain_tool "Permanent link")
```
to_langchain_tool(**langchain_tool_kwargs: ) -> 

```

To langchain tool.
Source code in `llama_index/core/tools/types.py`
```
198
199
200
201
202
203
204
205
206
207
208
209
210
211
```
| ```
def to_langchain_tool(
    self,
    **langchain_tool_kwargs: Any,
) -> "Tool":
"""To langchain tool."""
    from llama_index.core.bridge.langchain import Tool

    langchain_tool_kwargs = self._process_langchain_tool_kwargs(
        langchain_tool_kwargs
    )
    return Tool.from_function(
        func=self.__call__,
        **langchain_tool_kwargs,
    )

```
  
---|---  
###  to_langchain_structured_tool [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.BaseTool.to_langchain_structured_tool "Permanent link")
```
to_langchain_structured_tool(**langchain_tool_kwargs: ) -> StructuredTool

```

To langchain structured tool.
Source code in `llama_index/core/tools/types.py`
```
213
214
215
216
217
218
219
220
221
222
223
224
225
226
```
| ```
def to_langchain_structured_tool(
    self,
    **langchain_tool_kwargs: Any,
) -> "StructuredTool":
"""To langchain structured tool."""
    from llama_index.core.bridge.langchain import StructuredTool

    langchain_tool_kwargs = self._process_langchain_tool_kwargs(
        langchain_tool_kwargs
    )
    return StructuredTool.from_function(
        func=self.__call__,
        **langchain_tool_kwargs,
    )

```
  
---|---  
##  AsyncBaseTool [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.AsyncBaseTool "Permanent link")
Bases: 
Base-level tool class that is backwards compatible with the old tool spec but also supports async.
Source code in `llama_index/core/tools/types.py`
```
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
```
| ```
class AsyncBaseTool(BaseTool):
"""
    Base-level tool class that is backwards compatible with the old tool spec but also
    supports async.
    """

    def __call__(self, *args: Any, **kwargs: Any) -> ToolOutput:
        return self.call(*args, **kwargs)

    @abstractmethod
    def call(self, input: Any) -> ToolOutput:
"""
        This is the method that should be implemented by the tool developer.
        """

    @abstractmethod
    async def acall(self, input: Any) -> ToolOutput:
"""
        This is the async version of the call method.
        Should also be implemented by the tool developer as an
        async-compatible implementation.
        """

```
  
---|---  
###  call `abstractmethod` [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.AsyncBaseTool.call "Permanent link")
```
call(input: ) -> 

```

This is the method that should be implemented by the tool developer.
Source code in `llama_index/core/tools/types.py`
```
238
239
240
241
242
```
| ```
@abstractmethod
def call(self, input: Any) -> ToolOutput:
"""
    This is the method that should be implemented by the tool developer.
    """

```
  
---|---  
###  acall `abstractmethod` `async` [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.AsyncBaseTool.acall "Permanent link")
```
acall(input: ) -> 

```

This is the async version of the call method. Should also be implemented by the tool developer as an async-compatible implementation.
Source code in `llama_index/core/tools/types.py`
```
244
245
246
247
248
249
250
```
| ```
@abstractmethod
async def acall(self, input: Any) -> ToolOutput:
"""
    This is the async version of the call method.
    Should also be implemented by the tool developer as an
    async-compatible implementation.
    """

```
  
---|---  
##  BaseToolAsyncAdapter [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.BaseToolAsyncAdapter "Permanent link")
Bases: 
Adapter class that allows a synchronous tool to be used as an async tool.
Source code in `llama_index/core/tools/types.py`
```
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
```
| ```
class BaseToolAsyncAdapter(AsyncBaseTool):
"""
    Adapter class that allows a synchronous tool to be used as an async tool.
    """

    def __init__(self, tool: BaseTool):
        self.base_tool = tool

    @property
    def metadata(self) -> ToolMetadata:
        return self.base_tool.metadata

    def call(self, input: Any) -> ToolOutput:
        return self.base_tool(input)

    async def acall(self, input: Any) -> ToolOutput:
        return await asyncio.to_thread(self.call, input)

```
  
---|---  
##  adapt_to_async_tool [#](https://developers.llamaindex.ai/python/framework-api-reference/tools/#llama_index.core.tools.types.adapt_to_async_tool "Permanent link")
```
adapt_to_async_tool(tool: ) -> 

```

Converts a synchronous tool to an async tool.
Source code in `llama_index/core/tools/types.py`
```
272
273
274
275
276
277
278
279
```
| ```
def adapt_to_async_tool(tool: BaseTool) -> AsyncBaseTool:
"""
    Converts a synchronous tool to an async tool.
    """
    if isinstance(tool, AsyncBaseTool):
        return tool
    else:
        return BaseToolAsyncAdapter(tool)

```
  
---|---  
options: members: - AsyncBaseTool - BaseToolAsyncAdapter - BaseTool - ToolMetadata - ToolOutput
